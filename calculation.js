// --- FILE: calculation.js (FULL FILE - Short enough) ---

/**
 * List of finish names that should use the 'Painted' pricing.
 * @type {string[]} - Includes the base 'Painted' plus custom color names.
 */
const PAINTED_EQUIVALENT_FINISHES = [
  'Painted', // Base case
  'Accessible Beige 7036',
  'Card Room Green No.79',
  'BM White Dove OC-17',
  'Kendall Charcoal HC-166',
  'Van Deusen Blue', // Assuming this is one, add BM/SW prefix if needed
  "Stock White/ Decorator's White", // Combined name as provided
  'Custom Color', // Explicit custom color option
].map(f => f.toLowerCase()); // Use lowercase for case-insensitive matching

/**
 * Builds a map of door style to pricing group for quick lookup.
 * @param {Array} doorPricingGroups - Array of pricing group objects.
 * @returns {Object} - Map where keys are style names and values are price objects.
 */
function buildStylePriceMap(doorPricingGroups) {
  const styleMap = {};
  if (!Array.isArray(doorPricingGroups)) {
    console.error("[Calc] Invalid doorPricingGroups input:", doorPricingGroups);
    return styleMap;
  }
  for (const group of doorPricingGroups) {
    if (!group || !Array.isArray(group.styles)) continue;
    for (const style of group.styles) {
      if (typeof style === 'string') {
        styleMap[style] = {
          Painted: Number(group.Painted) || 0,
          Primed: Number(group.Primed) || 0,
          Unfinished: Number(group.Unfinished) || 0
        };
      }
    }
  }
  return styleMap;
}

/** Calculates the area in square feet. (No changes) */
function calculateArea(height, width) {
  const numHeight = parseFloat(height);
  const numWidth = parseFloat(width);
  if (isNaN(numHeight) || isNaN(numWidth) || numHeight <= 0 || numWidth <= 0) {
    return 0;
  }
  return (numHeight * numWidth) / 144;
}

/**
 * Gets the price for a given style and finish from the map.
 * Maps custom color names to 'Painted' for price lookup.
 * @param {Object} styleMap - The map generated by buildStylePriceMap.
 * @param {string} style - The door/drawer style name.
 * @param {string} finishInput - The finish type from the user input.
 * @returns {number} - Price per square foot, or 0 if not found.
 */
function getStylePrice(styleMap, style, finishInput) {
  // Determine the pricing category finish ('Painted', 'Primed', 'Unfinished')
  let pricingFinish = 'Painted'; // Default to Painted if unknown
  const lowerFinishInput = finishInput?.toLowerCase() ?? '';

  if (PAINTED_EQUIVALENT_FINISHES.includes(lowerFinishInput)) {
    pricingFinish = 'Painted';
  } else if (lowerFinishInput === 'primed') {
    pricingFinish = 'Primed';
  } else if (lowerFinishInput === 'unfinished') {
    pricingFinish = 'Unfinished';
  } else {
    // If it's not in the known lists, default to Painted but log a warning
    console.warn(`[Calc] Unknown finish "${finishInput}" received for style "${style}". Defaulting to 'Painted' pricing.`);
    pricingFinish = 'Painted';
  }

  // Lookup using the determined pricing category
  return styleMap?.[style]?.[pricingFinish] ?? 0;
}


/** Calculates the cost for a single section. (No direct changes needed) */
function calculateSectionCost(section, styleMap) {
  const area = calculateArea(section.height, section.width);
  // getStylePrice now handles mapping the finish name internally
  const doorPrice = getStylePrice(styleMap, section.doorStyle, section.finish);

  let drawerCost = 0;
  if (section.drawerStyle && section.drawerStyle !== section.doorStyle) {
      const drawerPrice = getStylePrice(styleMap, section.drawerStyle, section.finish);
      drawerCost = area * drawerPrice;
  }
  const doorCost = area * doorPrice;

  return {
    area: Number(area.toFixed(4)),
    doorCost: Number(doorCost.toFixed(2)),
    drawerCost: Number(drawerCost.toFixed(2)),
    totalSectionCost: Number((doorCost + drawerCost).toFixed(2)),
    doorStyle: section.doorStyle,
    drawerStyle: section.drawerStyle,
    finish: section.finish, // Return the original user-selected finish
    height: section.height,
    width: section.width
  };
}

/** Calculates total hinge cost. (No changes) */
function calculateHingeCost(part2, hingeCosts) {
  const d0_36 = Number(part2?.doors_0_36 || 0);
  const d36_60 = Number(part2?.doors_36_60 || 0);
  const d60_82 = Number(part2?.doors_60_82 || 0);
  const c0_36 = Number(hingeCosts?.["0-36"] || 0);
  const c36_60 = Number(hingeCosts?.["36.01-60"] || 0);
  const c60_82 = Number(hingeCosts?.["60.01-82"] || 0);

  if (c0_36 === 0 && c36_60 === 0 && c60_82 === 0 && (d0_36 > 0 || d36_60 > 0 || d60_82 > 0)) {
       console.warn("[Calc] Hinge counts provided, but hinge costs seem to be missing or zero in pricing data.");
  }

  return (d0_36 * c0_36) + (d36_60 * c36_60) + (d60_82 * c60_82);
}

/** Calculates costs for special features. (No changes) */
function calculateSpecialFeaturesCost(part3, customPaintPricing) {
  const qty = Number(part3?.customPaintQty || 0);
  const price = Number(customPaintPricing?.price || 0);
  if (price === 0 && qty > 0) {
       console.warn("[Calc] Custom paint quantity provided, but price is missing or zero in pricing data.");
  }
  return { customPaintCost: qty * price };
}

const format = (num) => Number((Number(num) || 0).toFixed(2));

/** Main calculation function. (No changes) */
function calculateOverallTotal(payload, pricingData) {
  if (!payload || typeof payload !== 'object') {
       throw new Error("Invalid payload provided for calculation.");
  }
  if (!pricingData || typeof pricingData !== 'object' || !pricingData.doorPricingGroups || !pricingData.hingeCosts || !pricingData.customPaint) {
       throw new Error("Invalid or incomplete pricing data provided for calculation.");
  }

  const styleMap = buildStylePriceMap(pricingData.doorPricingGroups);
  let sections = payload.sections || [];
  const part2 = payload.part2 || {};
  const part3 = payload.part3 || {};

  let totalAllSectionCost = 0;
  const sectionBreakdown = [];

  if (!Array.isArray(sections)) {
      console.warn("[Calc] Payload 'sections' is not an array. Defaulting to empty.", sections);
      sections = [];
  }

  for (const section of sections) {
    if (typeof section === 'object' && section !== null) {
         const result = calculateSectionCost(section, styleMap);
         sectionBreakdown.push(result);
         totalAllSectionCost += result.totalSectionCost;
    } else {
         console.warn("[Calc] Skipping invalid section data:", section);
    }
  }

  const hingeCost = calculateHingeCost(part2, pricingData.hingeCosts);
  const specialFeatures = calculateSpecialFeaturesCost(part3, pricingData.customPaint);
  const lazySusanPrice = Number(pricingData.lazySusan?.price || 0);
  const lazySusanQty = Number(part2.lazySusanQty || 0);
  const lazySusanTotalCost = lazySusanQty * lazySusanPrice;
  if (lazySusanPrice === 0 && lazySusanQty > 0) {
      console.warn("[Calc] Lazy Susan quantity provided, but price is missing or zero in pricing data.");
  }

  const overallTotal = totalAllSectionCost + hingeCost + specialFeatures.customPaintCost + lazySusanTotalCost;
  const hingeCount = (Number(part2?.doors_0_36 || 0) * 2) + (Number(part2?.doors_36_60 || 0) * 3) + (Number(part2?.doors_60_82 || 0) * 4);

  return {
    overallTotal: format(overallTotal),
    doorCostTotal: format(totalAllSectionCost),
    hingeCost: format(hingeCost),
    hingeCount,
    lazySusanCost: format(lazySusanTotalCost),
    specialFeatures: { customPaintCost: format(specialFeatures.customPaintCost) },
    sections: sectionBreakdown,
    part2: part2,
    part3: part3
  };
}

module.exports = {
  calculateOverallTotal
};